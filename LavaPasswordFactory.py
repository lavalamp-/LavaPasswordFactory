# -*- coding: utf-8 -*-
'''
@author: lavalamp

    Copyright 2014
    
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
'''
import logging
import tempfile
import base64
import gzip
import itertools
import argparse
from datetime import date
from datetime import datetime


top_ten_thousand_enc = "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"


class LavaUIFactory(object):

    # Colors
    BLACK = 30
    RED = 31
    GREEN = 32
    YELLOW = 33
    BLUE = 34
    MAGENTA = 35
    CYAN = 36
    WHITE = 37

    # Effects
    BOLD = 1
    FAINT = 2
    ITALIC = 3
    UNDERLINE = 4
    SLOW_BLINK = 5
    FAST_BLINK = 6

    # Escape codes
    ESCAPE_SEQUENCE = "\033[%sm"
    END_SEQUENCE = "\033[0m"

    # Lavalamp color map
    lavalamp_color_map = {
        "": [
            CYAN,
            BOLD
        ],
        "": [
            CYAN
        ],
        "": [
            CYAN
        ],
        "": [
            CYAN
        ],
        "": [
            RED,
            BOLD
        ],
        "": [
            RED,
            BOLD
        ],
        "": [
            RED
        ]
    }

    # Lavalamp splash
    lavalamp_splash = '''

                                            
                              
                                
                        
                           
                                     
                                                  
                                                               
                                                                   
                                                                              

'''

    @classmethod
    def apply_text_effects(cls, input_text, input_effects):
        effects = ";".join([str(x) for x in input_effects])
        begin_sequence = cls.ESCAPE_SEQUENCE % effects
        return begin_sequence + input_text + cls.END_SEQUENCE

    @classmethod
    def get_colorized_lavalamp_splash(cls):
        to_return = cls.lavalamp_splash
        for cur_key in cls.lavalamp_color_map.keys():
            effect_char = cls.apply_text_effects(
                cur_key,
                cls.lavalamp_color_map[cur_key]
            )
            to_return = to_return.replace(cur_key, effect_char)
        return to_return


class LavaPasswordChecker(object):

    def __init__(
            self,
            min_caps=None,
            max_caps=None,
            min_special_chars=None,
            max_special_chars=None,
            min_length=None,
            max_length=None,
            illegal_chars=None,
            special_chars="!@#$%^&*()-_=+{}|[]\\;:'\",<.>/?",
            *args,
            **kwargs
            ):
        self._min_caps = min_caps
        self._max_caps = max_caps
        self._min_special_chars = min_special_chars
        self._max_special_chars = max_special_chars
        self._min_length = min_length
        self._max_length = max_length
        self._illegal_chars = illegal_chars
        self._special_chars = special_chars
        self.__report_to_log()

    def __report_to_log(self):
        logger.info("LavaPasswordChecker instantiated with the following constraints:")
        if self._min_caps:
            logger.info(
                "- Passwords must contain at least %d capital letters."
                % (self._min_caps)
            )
        if self._max_caps:
            logger.info(
                "- Passwords must contain at most %d capital letters."
                % (self._max_caps)
            )
        if self._min_special_chars:
            logger.info(
                "- Passwords must contain at least %d special characters."
                % (self._min_special_chars)
            )
        if self._max_special_chars:
            logger.info(
                "- Passwords must contain at most %d special characters."
                % (self._max_special_chars)
            )
        if self._min_length:
            logger.info(
                "- Passwords must be at least %d characters long."
                % (self._min_length)
            )
        if self._max_length:
            logger.info(
                "- Passwords must be at most %d characters long."
                % (self._max_length)
            )
        if self._illegal_chars:
            logger.info(
                "- The follow characters are not allowed in the password list: %s."
                % (self._illegal_chars)
            )
        logger.info(
            "- The characters included in the 'special characters' list are: %s."
            % self._special_chars
        )

    def is_valid(self, term):
        """Checks to see if the input term is a valid password based on the
        configuration of the given LavaPasswordChecker.
        """
        if self._min_caps:
            if len(filter(lambda x: x.isupper(), term)) < self._min_caps:
                return False
        if self._max_caps:
            if len(filter(lambda x: x.isupper(), term)) > self._max_caps:
                return False
        if self._min_special_chars:
            if len(filter(lambda x: x in self._special_chars, term)) < self._min_special_chars:
                return False
        if self._max_special_chars:
            if len(filter(lambda x: x in self._special_chars, term)) > self._max_special_chars:
                return False
        if self._min_length:
            if len(term) < self._min_length:
                return False
        if self._max_length:
            if len(term) > self._max_length:
                return False
        if self._illegal_chars:
            if filter(lambda x: x in self._illegal_chars, term):
                return False
        return True

    def filter_list(self, input_list):
        """Filters the input list by all of the rules associated with the
        given LavaPasswordChecker.
        """
        logger.info(
            "Starting filtering process with list of length %d."
            % (len(input_list))
        )
        slen = len(input_list)
        if self._min_caps:
            blen = len(input_list)
            input_list = filter(lambda x: sum([1 if y.isupper() else 0 for y in x]) >= self._min_caps, input_list)
            logger.debug(
                "A total of %d terms were removed based on minimum caps restriction of %d. New length is %d."
                % (blen - len(input_list), self._min_caps, len(input_list))
            )
        if self._max_caps:
            blen = len(input_list)
            input_list = filter(lambda x: sum([1 if y.isupper() else 0 for y in x]) <= self._max_caps, input_list)
            logger.debug(
                "A total of %d terms were removed based on maximum caps restriction of %d. New length is %d."
                % (blen - len(input_list), self._max_caps, len(input_list))
            )
        if self._min_special_chars:
            blen = len(input_list)
            input_list = filter(lambda x: sum([1 if y in self._special_chars else 0 for y in x]) >= self._min_special_chars, input_list)
            logger.debug(
                "A total of %d terms were removed based on minimum special characters restriction of %d. New length is %d."
                % (blen - len(input_list), self._min_special_chars, len(input_list))
            )
        if self._max_special_chars:
            blen = len(input_list)
            input_list = filter(lambda x: sum([1 if y in self._special_chars else 0 for y in x]) <= self._max_special_chars, input_list)
            logger.debug(
                "A total of %d terms were removed based on maximum special characters restriction of %d. New length is %d."
                % (blen - len(input_list), self._max_special_chars, len(input_list))
            )
        if self._min_length:
            blen = len(input_list)
            input_list = filter(lambda x: len(x) >= self._min_length, input_list)
            logger.debug(
                "A total of %d terms were removed based on minimum term length restriction of %d. New length is %d."
                % (blen - len(input_list), self._min_length, len(input_list))
            )
        if self._max_length:
            blen = len(input_list)
            input_list = filter(lambda x: len(x) <= self._max_length, input_list)
            logger.debug(
                "A total of %d terms were removed based on maximum term length restriction of %d. New length is %d."
                % (blen - len(input_list), self._max_length, len(input_list))
            )
        if self._illegal_chars:
            blen = len(input_list)
            input_list = filter(lambda x: sum([1 if y in self._illegal_chars else 0 for y in x]) == 0, input_list) #TODO clean this up
            logger.debug(
                "A total of %d terms were removed based on the illegal character list of %s. New length is %d."
                % (blen - len(input_list), self._illegal_chars, len(input_list))
            )
        blen = len(input_list)
        input_list = list(set(input_list))
        logger.debug(
            "A total of %d terms were removed as duplicates. New length is %d."
            % (blen - len(input_list), len(input_list))
        )
        logger.info(
            "A grand total of %d terms were removed in the filtering process. New list length is %d."
            % (slen-len(input_list), len(input_list))
        )
        return input_list


class LavaLogFormatter(logging.Formatter):

    BLUE = "\033[94m"
    GREEN = "\033[92m"
    RED = "\033[91m"
    NONE = "\033[0m"
    CYAN = "\033[96m"
    MAGENTA = "\033[95m"
    YELLOW = "\033[33m"

    CRITICAL = RED + "%(asctime)s [ C ] %(message)s" + NONE
    ERROR = "%(asctime)s [" + RED + " E " + NONE + "] %(message)s"
    WARNING = "%(asctime)s [" + YELLOW + " W " + NONE + "] %(message)s"
    INFO = "%(asctime)s [" + GREEN + " I " + NONE + "] %(message)s"
    DEBUG = "%(asctime)s [" + BLUE + " D " + NONE + "] %(message)s"

    def __init__(self):
        super(LavaLogFormatter, self).__init__(datefmt="[%m/%d %H:%M:%S]")
    # self.datefmt = "[%m/%d %H:%M:%S]"

    def format(self, record):
        if record.levelno == logging.CRITICAL:
            self._fmt = LavaLogFormatter.CRITICAL
        elif record.levelno == logging.ERROR:
            self._fmt = LavaLogFormatter.ERROR
        elif record.levelno == logging.WARNING:
            self._fmt = LavaLogFormatter.WARNING
        elif record.levelno == logging.INFO:
            self._fmt = LavaLogFormatter.INFO
        elif record.levelno == logging.DEBUG:
            self._fmt = LavaLogFormatter.DEBUG
        return super(LavaLogFormatter, self).format(record)


class LavaPasswordFactory(object):
    """A class for creating password lists for both online and offline attacks.

    The LavaPasswordFactory takes a list of words as inputs and,
    depending on whether the LavaPasswordFactory is initialized for online
    (is_list_large=False) or offline (is_list_large=True) attacks, will produce
    an appropriately-sized list of potential passwords. In both modes, the
    generation process will use the seed_list property as the list to base all
    other permutations off of. In online mode, the seed_list property will
    contain all of the words in the input list in lowercase, uppercase, snake
    case, and title case format (ie: ['one', 'two'] becomes ['one', 'ONE',
    'One', 'two', 'TWO', 'Two', 'OnE', 'TwO']). In offline mode, the seed_list
    will contain all items within the online mode in addition to all possible
    non-repeating permutations of the words. As this is the list that all
    other password creation processes is based off of, the size of this list
    is exponentially (if not combinatorially) related to the size of the output
    password list.

    The following terms are used to describe smaller password lists which are
    used as components in building finalized password lists:

    - [WORD] - Words from the seed_list property.
    - [PASS] - Common password terms (ie: password, secret, access). The list
        of common terms depends on the running mode (offline vs. online) of 
        the LavaPasswordFactory instance.
    - [PASS 1337] - 1337-speak permutations of common password terms. The list
        of common terms depends on the running mode (offline vs. online) of
        the LavaPasswordFactory instance.
    - [WORD 1337] - 1337-speak permutations of the words in the seed_list
        property. The number of possible character replacements as well as
        the number of maximum characters replaced per word is determined
        by the running mode (offline vs. online) of the LavaPasswordFactory.
        In offline mode, up to five characters are replaced, whereas in online
        mode up to three are replaced.
    - [<NUM> DIGIT #] - A number that is up to <NUM> digits long.
    - [MONTH] - A three-character abbreviation of all the months in the year
        (ie: nov, dec, jan, .. ). When in offline mode, all of the months
        will also be capitalized as well as title cased.
    - [YEAR SHORT] - A two digit representation of the year (ie: 1988 is 88).
        When in online mode, the number of years that this list goes back
        is 50, whereas in offline mode it goes back 100.
    - [YEAR LONG] - A four digit representation of the year. When in online
        mode, the number of years that this list goes back is 50, whereas in
        offline mode it goes back 100.
    - [NUM SHIFT] - A list of all digits on the QWERTY keyboard with the
        special character that occurs when shift is held when hitting that
        digit (ie: 1!, 2@, 3#, .. ). In offline mode, the order of these will be
        switched as well (ie: !1, @2, #3, .. ).
    - [CHAR <CHAR>] - This denotes the placement of a single character. For
        instance, [CHAR _] means placing the character "_" in the identified
        location.
    - [1234] - The sequence of characters "1234".
    - [<NUM> DIGIT SPECIAL] - <NUM> special characters from the shift+number 
        key range with the rule that the two special characters must be right
        next to one another on the keyboard (ex: !@, @#. #$, $%, .. )

    The following passwords are generated both in online and offline modes:

    - [WORD]
    - [WORD] + [1 DIGIT #]
    - [WORD] + [2 DIGIT #]
    - [WORD] + [3 DIGIT #]
    - [WORD] + [NUM SHIFT]
    - [WORD] + [2 DIGIT SPECIAL]
    - [WORD] + [3 DIGIT SPECIAL]
    - [WORD 1337]
    - [WORD 1337] + [1 DIGIT #]
    - [WORD 1337] + [2 DIGIT #]
    - [WORD 1337] + [3 DIGIT #]
    - [WORD 1337] + [NUM SHIFT]
    - [WORD 1337] + [2 DIGIT SPECIAL]
    - [WORD 1337] + [3 DIGIT SPECIAL]
    - [PASS]
    - [PASS] + [1 DIGIT #]
    - [PASS] + [2 DIGIT #]
    - [PASS] + [3 DIGIT #]
    - [PASS] + [NUM SHIFT]
    - [PASS] + [2 DIGIT SPECIAL]
    - [PASS] + [3 DIGIT SPECIAL]
    - [PASS 1337]
    - [PASS 1337] + [1 DIGIT #]
    - [PASS 1337] + [2 DIGIT #]
    - [PASS 1337] + [3 DIGIT #]
    - [PASS 1337] + [NUM SHIFT]
    - [PASS 1337] + [2 DIGIT SPECIAL]
    - [PASS 1337] + [3 DIGIT SPECIAL]
    - [WORD] + [PASS]
    - [WORD 1337] + [PASS]
    - [WORD] + [PASS 1337]
    - [WORD 1337] + [PASS 1337]
    - [WORD] + [PASS]
    - [WORD] + [MONTH] + [YEAR SHORT]
    - [WORD] + [MONTH] + [YEAR LONG]
    - [WORD] + [1234]

    The following passwords are generated in offline mode only:

    - [WORD 1337] + [1 DIGIT #]
    - [WORD 1337] + [2 DIGIT #]
    - [WORD] + [PASS 1337]
    - [WORD] + [PASS 1337] + [1 DIGIT #]
    - [WORD] + [YEAR SHORT]
    - [WORD] + [YEAR LONG]
    - [WORD 1337] + [YEAR SHORT]
    - [WORD 1337] + [YEAR LONG]
    - [WORD 1337] + [MONTH] + [YEAR SHORT]
    - [WORD 1337] + [MONTH] + [YEAR LONG]
    - [PASSWORD] + [MONTH] + [YEAR SHORT]
    - [PASSWORD] + [MONTH] + [YEAR LONG]
    - [PASSWORD 1337] + [MONTH] + [YEAR SHORT]
    - [PASSWORD 1337] + [MONTH] + [YEAR LONG]
    - [WORD] + [CHAR _] + [PASSWORD]
    - [WORD] + [CHAR _] + [PASSWORD 1337]
    - [WORD 1337] + [1234]
    - [PASS] + [WORD]
    - [1 DIGIT #] + [WORD 1337]
    - [2 DIGIT #] + [WORD 1337]
    - [NUM SHIFT] + [WORD]
    - [WORD] + [PASS 1337] + [2 DIGIT #]
    - [1234] + [WORD]
    - [1234] + [WORD 1337]

    """

    _common_replacements = {
        "a": [
            "@",
            "4",
            ],
        "e": [
            "3",
            ],
        "i": [
            "1",
            "!",
            "|",
            ],
        "s": [
            "$",
            "5",
            ],
        "t": [
            "7",
            "1",
            ],
        "b": [
            "8",
            ],
        "g": [
            "6",
            "9",
            ],
        "l": [
            "1",
            "!",
            "|",
            ],
        "o": [
            "0"
            ],
    }
    _password_list_large = [
        'password',
        'PASSWORD',
        'Password',
        'PaSsWoRd',
        'pass',
        'PASS',
        'Pass',
        'PaSs',
        'admin',
        'ADMIN',
        'Admin',
        'AdMiN',
        'secret',
        'SECRET',
        'Secret',
        'SeCrEt',
        'access',
        'ACCESS',
        'Access',
        'AcCeSs',
    ]
    _password_list_small = [
        'password',
        'PASSWORD',
        'Password',
        'PaSsWoRd',
        'pass',
        'PASS',
        'Pass',
        'PaSs',
        'admin',
        'Admin',
        'secret',
        'Secret'
    ]

    def __init__(
            self,
            input_list,
            is_offline=False,
            min_length=8,
            max_length=12,
            *args,
            **kwargs
            ):
        self._is_offline = is_offline
        self._input_list = input_list
        self._max_leet_replace = 5 if self._is_offline else 3
        self._min_length = min_length
        self._max_length = max_length
        self.__expand_common_replacements()

    def __do_leet_replacements(self, input_list):
        to_return = []
        special_keys = self._common_replacements.keys()
        for cur_item in input_list:
            rep_positions = []
            for (counter, char) in enumerate(cur_item):
                if char in special_keys:
                    rep_positions.append(counter)
            for perm_size in range(1, self._max_leet_replace+1):
                rep_possibilities = itertools.combinations(rep_positions, perm_size)
                for cur_possibility in rep_possibilities:
                    to_return.extend(self.__replace_characters_at_positions(cur_item, cur_possibility))
        logger.debug(
            "Completed special character replacement. Input list length: %d. Input permutation length range: [%d, %d]. Resulting list length: %d."
            % (len(input_list), 1, self._max_leet_replace, len(to_return))
        )
        return to_return

    def __expand_common_replacements(self):
        for curkey in self._common_replacements.keys():
            self._common_replacements[curkey.upper()] = self._common_replacements[curkey]

    def __gen(self, input_length):
        logger.info(
            "Now starting generation of passwords of length %d."
            % (input_length)
        )
        month_year_short = ["".join(x) for x in itertools.product(self.months, self.years_short)]
        month_year_long = ["".join(x) for x in itertools.product(self.months, self.years_long)]
        self.__log_for_length("[WORD]", input_length)
        for pw in self.word_list:
            yield pw[:input_length]
        self.__log_for_length("[WORD] + [1 DIGIT #]", input_length)
        for pw in ["".join(x) for x in itertools.product([y[:input_length-1] for y in self.word_list], self.one_digit_numbers)]:
            yield pw
        self.__log_for_length("[WORD] + [2 DIGIT #]", input_length)
        for pw in ["".join(x) for x in itertools.product([y[:input_length-2] for y in self.word_list], self.two_digit_numbers)]:
            yield pw
        self.__log_for_length("[WORD] + [3 DIGIT #]", input_length)
        for pw in ["".join(x) for x in itertools.product([y[:input_length-3] for y in self.word_list], self.three_digit_numbers)]:
            yield pw
        self.__log_for_length("[WORD] + [NUM SHIFT]", input_length)
        for pw in ["".join(x) for x in itertools.product([y[:input_length-2] for y in self.word_list], self.num_shift)]:
            yield pw
        self.__log_for_length("[WORD] + [2 DIGIT SPECIAL]", input_length)
        for pw in ["".join(x) for x in itertools.product([y[:input_length-2] for y in self.word_list], self.two_digit_specials)]:
            yield pw
        self.__log_for_length("[WORD] + [3 DIGIT SPECIAL]", input_length)
        for pw in ["".join(x) for x in itertools.product([y[:input_length-3] for y in self.word_list], self.three_digit_specials)]:
            yield pw
        self.__log_for_length("[WORD 1337]", input_length)
        for pw in self.word_list_leet:
            yield pw[:input_length]
        self.__log_for_length("[WORD 1337] + [1 DIGIT #]", input_length)
        for pw in ["".join(x) for x in itertools.product([y[:input_length-1] for y in self.word_list_leet], self.one_digit_numbers)]:
            yield pw
        self.__log_for_length("[WORD 1337] + [2 DIGIT #]", input_length)
        for pw in ["".join(x) for x in itertools.product([y[:input_length-2] for y in self.word_list_leet], self.two_digit_numbers)]:
            yield pw
        self.__log_for_length("[WORD 1337] + [3 DIGIT #]", input_length)
        for pw in ["".join(x) for x in itertools.product([y[:input_length-3] for y in self.word_list_leet], self.three_digit_numbers)]:
            yield pw
        self.__log_for_length("[WORD 1337] + [NUM SHIFT]", input_length)
        for pw in ["".join(x) for x in itertools.product([y[:input_length-2] for y in self.word_list_leet], self.num_shift)]:
            yield pw
        self.__log_for_length("[WORD 1337] + [2 DIGIT SPECIAL]", input_length)
        for pw in ["".join(x) for x in itertools.product([y[:input_length-2] for y in self.word_list_leet], self.two_digit_specials)]:
            yield pw
        self.__log_for_length("[WORD 1337] + [3 DIGIT SPECIAL]", input_length)
        for pw in ["".join(x) for x in itertools.product([y[:input_length-3] for y in self.word_list_leet], self.three_digit_specials)]:
            yield pw
        self.__log_for_length("[PASS]", input_length)
        for pw in self.password_list:
            yield pw[:input_length]
        self.__log_for_length("[PASS] + [1 DIGIT #]", input_length)
        for pw in ["".join(x) for x in itertools.product([y[:input_length-1] for y in self.password_list], self.one_digit_numbers)]:
            yield pw
        self.__log_for_length("[PASS] + [2 DIGIT #]", input_length)
        for pw in ["".join(x) for x in itertools.product([y[:input_length-2] for y in self.password_list], self.two_digit_numbers)]:
            yield pw
        self.__log_for_length("[PASS] + [3 DIGIT #]", input_length)
        for pw in ["".join(x) for x in itertools.product([y[:input_length-3] for y in self.password_list], self.three_digit_numbers)]:
            yield pw
        self.__log_for_length("[PASS] + [NUM SHIFT]", input_length)
        for pw in ["".join(x) for x in itertools.product([y[:input_length-2] for y in self.password_list], self.num_shift)]:
            yield pw
        self.__log_for_length("[PASS] + [2 DIGIT SPECIAL]", input_length)
        for pw in ["".join(x) for x in itertools.product([y[:input_length-2] for y in self.password_list], self.two_digit_specials)]:
            yield pw
        self.__log_for_length("[PASS] + [3 DIGIT SPECIAL]", input_length)
        for pw in ["".join(x) for x in itertools.product([y[:input_length-3] for y in self.password_list], self.three_digit_specials)]:
            yield pw
        self.__log_for_length("[PASS 1337]", input_length)
        for pw in self.password_list_leet:
            yield pw[:input_length]
        self.__log_for_length("[PASS 1337] + [1 DIGIT #]", input_length)
        for pw in ["".join(x) for x in itertools.product([y[:input_length-1] for y in self.password_list_leet], self.one_digit_numbers)]:
            yield pw
        self.__log_for_length("[PASS 1337] + [2 DIGIT #]", input_length)
        for pw in ["".join(x) for x in itertools.product([y[:input_length-2] for y in self.password_list_leet], self.two_digit_numbers)]:
            yield pw
        self.__log_for_length("[PASS 1337] + [3 DIGIT #]", input_length)
        for pw in ["".join(x) for x in itertools.product([y[:input_length-3] for y in self.password_list_leet], self.three_digit_numbers)]:
            yield pw
        self.__log_for_length("[PASS 1337] + [NUM SHIFT]", input_length)
        for pw in ["".join(x) for x in itertools.product([y[:input_length-2] for y in self.password_list_leet], self.num_shift)]:
            yield pw
        self.__log_for_length("[PASS 1337] + [2 DIGIT SPECIAL]", input_length)
        for pw in ["".join(x) for x in itertools.product([y[:input_length-2] for y in self.password_list_leet], self.two_digit_specials)]:
            yield pw
        self.__log_for_length("[PASS 1337] + [3 DIGIT SPECIAL]", input_length)
        for pw in ["".join(x) for x in itertools.product([y[:input_length-3] for y in self.password_list_leet], self.three_digit_specials)]:
            yield pw
        self.__log_for_length("[WORD] + [PASS]", input_length)
        for pw in ["".join(x) for x in itertools.product(self.word_list, self.password_list)]:
            yield pw[:input_length]
        self.__log_for_length("[WORD 1337] + [PASS]", input_length)
        for pw in ["".join(x) for x in itertools.product(self.word_list_leet, self.password_list)]:
            yield pw[:input_length]
        self.__log_for_length("[WORD] + [PASS 1337]", input_length)
        for pw in ["".join(x) for x in itertools.product(self.word_list, self.password_list_leet)]:
            yield pw[:input_length]
        self.__log_for_length("[WORD 1337] + [PASS 1337]", input_length)
        for pw in ["".join(x) for x in itertools.product(self.word_list_leet, self.password_list_leet)]:
            yield pw[:input_length]
        self.__log_for_length("[WORD] + [MONTH] + [YEAR SHORT]", input_length)
        for pw in ["".join(x) for x in itertools.product([y[:input_length-5] for y in self.word_list], month_year_short)]:
            yield pw
        self.__log_for_length("[WORD] + [MONTH] + [YEAR LONG]", input_length)
        for pw in ["".join(x) for x in itertools.product([y[:input_length-7] for y in self.word_list], month_year_long)]:
            yield pw
        self.__log_for_length("[WORD] + [1234]", input_length)
        for pw in ["".join(x) for x in itertools.product([y[:input_length-4] for y in self.word_list], ["1234", ])]:
            yield pw
        if self._is_offline:
            word_pass_leet = ["".join(x) for x in itertools.product(self.word_list, self.password_list_leet)]
            word_char__ = ["".join(x) for x in itertools.product(self.word_list, ["_", ])]
            self.__log_for_length("[WORD 1337] + [1 DIGIT #]", input_length)
            for pw in ["".join(x) for x in itertools.product([y[:input_length-1] for y in self.word_list_leet], self.one_digit_numbers)]:
                yield pw
            self.__log_for_length("[WORD 1337] + [2 DIGIT #]", input_length)
            for pw in ["".join(x) for x in itertools.product([y[:input_length-2] for y in self.word_list_leet], self.two_digit_numbers)]:
                yield pw
            self.__log_for_length("[WORD] + [PASS 1337]", input_length)
            for pw in word_pass_leet:
                yield pw[:input_length]
            self.__log_for_length("[WORD] + [PASS 1337] + [1 DIGIT #]", input_length)
            for pw in ["".join(x) for x in itertools.product([y[:input_length-1] for y in word_pass_leet], self.one_digit_numbers)]:
                yield pw
            self.__log_for_length("[WORD] + [YEAR SHORT]", input_length)
            for pw in ["".join(x) for x in itertools.product([y[:input_length-2] for y in self.word_list], self.years_short)]:
                yield pw
            self.__log_for_length("[WORD] + [YEAR LONG]", input_length)
            for pw in ["".join(x) for x in itertools.product([y[:input_length-4] for y in self.word_list], self.years_long)]:
                yield pw
            self.__log_for_length("[WORD 1337] + [YEAR SHORT]", input_length)
            for pw in ["".join(x) for x in itertools.product([y[:input_length-2] for y in self.word_list_leet], self.years_short)]:
                yield pw
            self.__log_for_length("[WORD 1337] + [YEAR LONG]", input_length)
            for pw in ["".join(x) for x in itertools.product([y[:input_length-4] for y in self.word_list_leet], self.years_long)]:
                yield pw
            self.__log_for_length("[WORD 1337] + [MONTH] + [YEAR SHORT]", input_length)
            for pw in ["".join(x) for x in itertools.product([y[:input_length-5] for y in self.word_list_leet], month_year_short)]:
                yield pw
            self.__log_for_length("[WORD 1337] + [MONTH] + [YEAR LONG]", input_length)
            for pw in ["".join(x) for x in itertools.product([y[:input_length-7] for y in self.word_list_leet], month_year_long)]:
                yield pw
            self.__log_for_length("[PASSWORD] + [MONTH] + [YEAR SHORT]", input_length)
            for pw in ["".join(x) for x in itertools.product([y[:input_length-5] for y in self.password_list], month_year_short)]:
                yield pw
            self.__log_for_length("[PASSWORD] + [MONTH] + [YEAR LONG]", input_length)
            for pw in ["".join(x) for x in itertools.product([y[:input_length-7] for y in self.password_list], month_year_long)]:
                yield pw
            self.__log_for_length("[PASSWORD 1337] + [MONTH] + [YEAR SHORT]", input_length)
            for pw in ["".join(x) for x in itertools.product([y[:input_length-5] for y in self.password_list_leet], month_year_short)]:
                yield pw
            self.__log_for_length("[PASSWORD 1337] + [MONTH] + [YEAR LONG]", input_length)
            for pw in ["".join(x) for x in itertools.product([y[:input_length-7] for y in self.password_list_leet], month_year_long)]:
                yield pw
            self.__log_for_length("[WORD] + [CHAR _] + [PASSWORD]", input_length)
            for pw in ["".join(x) for x in itertools.product(word_char__, self.password_list)]:
                yield pw[:input_length]
            self.__log_for_length("[WORD] + [CHAR _] + [PASSWORD 1337]", input_length)
            for pw in ["".join(x) for x in itertools.product(word_char__, self.password_list_leet)]:
                yield pw[:input_length]
            self.__log_for_length("[WORD 1337] + [1234]", input_length)
            for pw in ["".join(x) for x in itertools.product([y[:input_length-4] for y in self.word_list_leet], ["1234", ])]:
                yield pw
            self.__log_for_length("[PASS] + [WORD]", input_length)
            for pw in ["".join(x) for x in itertools.product(self.password_list, self.word_list)]:
                yield pw[:input_length]
            self.__log_for_length("[1 DIGIT #] + [WORD 1337]", input_length)
            for pw in ["".join(x) for x in itertools.product(self.one_digit_numbers, [y[:input_length-1] for y in self.word_list_leet])]:
                yield pw
            self.__log_for_length("[2 DIGIT #] + [WORD 1337]", input_length)
            for pw in ["".join(x) for x in itertools.product(self.two_digit_numbers, [y[:input_length-2] for y in self.word_list_leet])]:
                yield pw
            self.__log_for_length("[NUM SHIFT] + [WORD]", input_length)
            for pw in ["".join(x) for x in itertools.product(self.num_shift, [y[:input_length-2] for y in self.word_list_leet])]:
                yield pw
            self.__log_for_length("[WORD] + [PASS 1337] + [2 DIGIT #]", input_length)
            for pw in ["".join(x) for x in itertools.product([y[:input_length-2] for y in word_pass_leet], self.two_digit_numbers)]:
                yield pw
            self.__log_for_length("[1234] + [WORD]", input_length)
            for pw in ["".join(x) for x in itertools.product(["1234", ], [y[:input_length-4] for y in self.word_list])]:
                yield pw
            self.__log_for_length("[1234] + [WORD 1337]", input_length)
            for pw in ["".join(x) for x in itertools.product(["1234", ], [y[:input_length-4] for y in self.word_list_leet])]:
                yield pw
        logger.info(
            "Password generation of length %d completed."
            % (input_length)
        )

    def __log_for_length(self, term, length):
        logger.debug(
            "Generating %s with length <= %d."
            % (term, length)
        )

    def __replace_characters_at_positions(self, input_string, input_positions):
        rep_list = [input_string, ]
        for cur_position in input_positions:
            cur_list = []
            for cur_replacement in self._common_replacements[input_string[cur_position]]:
                for cur_string in rep_list:
                    csl = list(cur_string)
                    csl[cur_position] = cur_replacement
                    cur_list.append("".join(csl))
            rep_list = cur_list
        return rep_list

    def gen(self):
        """Generates all of the passwords as configured by the
        LavaPasswordFactory instance.
        """
        logger.info("Now starting full password list generation.")
        for x in range(self._min_length, self._max_length + 1):
            for y in self.__gen(x):
                yield y
        logger.info("Completed full password list generation.")

    @property
    def num_shift(self):
        try:
            self._num_shift
        except:
            logger.debug("Generating the num_shift property.")
            self._num_shift = ['1!', '2@', '3#', '4$', '5%', '6^', '7&', '8*', '9(', '0)']
            if self._is_offline:
                self._num_shift.extend(['!1', '@2', '#3', '$4', '%5', '^6', '&7', '*8', '(9', ')0'])
        return self._num_shift

    @property
    def years_long(self):
        try:
            self._years_long
        except:
            logger.debug("Generating years_long property.")
            back = 100 if self._is_offline else 50
            this_year = date.today().year
            self._years_long = [str(x) for x in range(this_year - back,this_year + 1)]
        return self._years_long

    @property
    def years_short(self):
        try:
            self._years_short
        except:
            logger.debug("Generating years_short property.")
            back = 100 if self._is_offline else 50
            this_year = date.today().year
            self._years_short = [str(x)[2:] for x in range(this_year - back,this_year + 1)]
        return self._years_short

    @property
    def months(self):
        try:
            self._months
        except:
            logger.debug("Generating months property.")
            months = ['jan', 'feb', 'mar', 'apr', 'may', 'jun', 'jul', 'aug', 'sep', 'oct', 'nov', 'dec']
            self._months = []
            self._months.extend(months)
            if self._is_offline:
                self._months.extend([x.upper() for x in months])
                self._months.extend([x.title() for x in months])
        return self._months

    @property
    def three_digit_numbers(self):
        try:
            self._three_digit_numbers
        except:
            logger.debug("Generating three_digit_numbers property.")
            self._three_digit_numbers = [str(x) for x in list(range(100,1000))]
        return self._three_digit_numbers

    @property
    def two_digit_numbers(self):
        try:
            self._two_digit_numbers
        except:
            logger.debug("Generating two_digit_numbers property.")
            self._two_digit_numbers = [str(x).zfill(2) for x in list(range(0,100))]
        return self._two_digit_numbers

    @property
    def one_digit_numbers(self):
        try:
            self._single_digit_numbers
        except:
            logger.debug("Generating one_digit_numbers property.")
            self._single_digit_numbers = [str(x) for x in list(range(0,10))]
        return self._single_digit_numbers

    @property
    def three_digit_specials(self):
        try:
            self._three_digit_specials
        except:
            logger.debug("Generating three_digit_specials property.")
            self._three_digit_specials = ['!@#', '@#$', '#$%', '$%^', '%^&', '^&*', '&*(', '*()']
        return self._three_digit_specials

    @property
    def two_digit_specials(self):
        try:
            self._two_digit_specials
        except:
            logger.debug("Generating two_digit_specials property.")
            self._two_digit_specials = ['!@', '@#', '#$', '$%', '%^', '^&', '&*', '*(', '()']
        return self._two_digit_specials

    @property
    def password_list_leet(self):
        try:
            self._password_list_leet
        except:
            logger.debug("Generating password_list_leet property.")
            self._password_list_leet = self.__do_leet_replacements(self.password_list)
        return self._password_list_leet

    @property
    def password_list(self):
        try:
            self._password_list
        except:
            logger.debug("Setting password_list property.")
            self._password_list = self._password_list_large if self._is_offline else self._password_list_small
        return self._password_list

    @property
    def word_list_leet(self):
        try:
            self._word_list_leet
        except:
            logger.debug("Generating word_list_leet property.")
            self._word_list_leet = self.__do_leet_replacements(self.word_list)
        return self._word_list_leet

    @property
    def basic_transformations(self):
        """Get a list of all of the words supplied to the LavaPasswordFactory
        instance in full lowercase, full uppercase, and title case.
        """
        try:
            self._basic_transformations
        except:
            logger.debug("Generating basic_transformations property.")
            self._basic_transformations = [x.lower() for x in self._input_list]
            self._basic_transformations.extend([x.upper() for x in self._input_list])
            self._basic_transformations.extend([x.lower().title() for x in self._input_list])
            self._basic_transformations.extend(["".join([x[n].lower() if n%2 else x[n].upper() for n in range(len(x))]) for x in self._input_list])
        return self._basic_transformations

    @property
    def basic_permutations(self):
        """Get a list of passwords where the LavaPasswordFactory's
        seed list is permuted with itself. For instance, a list of
        ['one', 'two'] will give a basic_permutations of ['one', 'two',
        'onetwo', 'twoone'].
        """
        try:
            self._basic_permutations
        except:
            logger.debug("Generating basic_permutations property.")
            self._basic_permutations = []
            for permutation_length in range(1, len(self.basic_transformations) + 1):
                cur_set = []
                p = set(itertools.permutations(self.basic_transformations, permutation_length))
                # This is to prevent same word occurring twice, such as wordWORD
                for cur_tuple in p:
                    test_set = set([x.lower() for x in cur_tuple])
                    if len(test_set) == len(cur_tuple):
                        if len(cur_tuple) == 1:
                            cur_set.append(cur_tuple[0])
                        else:
                            cur_set.append("".join(cur_tuple))
                self._basic_permutations.extend(cur_set)
        return self._basic_permutations

    @property
    def word_list(self):
        """Get the basic list of terms that is used as a seed list
        for all other permutations performed by the LavaPasswordFactory.
        """
        return self.basic_permutations if self._is_offline else self.basic_transformations


def clean_arguments(arguments):
    try:
        arguments.input_list = arguments.input_list.strip().split(" ")
    except:
        pass
    return arguments


def configure_logging(input_level="DEBUG"):
    if input_level == "INFO":
        lvl = logging.INFO
    elif input_level == "WARNING":
        lvl = logging.WARNING
    elif input_level == "ERROR":
        lvl = logging.ERROR
    elif input_level == "CRITICAL":
        lvl = logging.CRITICAL
    elif input_level == "DEBUG":
        lvl = logging.DEBUG
    logger.setLevel(lvl)
    formatter = LavaLogFormatter()
    stream_handler = logging.StreamHandler()
    stream_handler.setFormatter(formatter)
    logger.addHandler(stream_handler)


def do_clean(input_args):
    opts = vars(input_args)
    lpc = LavaPasswordChecker(**opts)
    logger.info(
        "Now cleaning passwords found in file '%s' and writing valid passwords to '%s'."
        % (input_args.input_file, input_args.output_file)
    )
    num_lines = 0
    num_pass = 0
    num_fail = 0
    with open(input_args.input_file, 'r') as fi:
        with open(input_args.output_file, 'w+') as fo:
            for cur_pass in fi:
                num_lines += 1
                if lpc.is_valid(cur_pass):
                    num_pass += 1
                    fo.write(cur_pass + "\n")
                else:
                    num_fail += 1
                if num_lines % 500000 == 0:
                    logger.info(
                        "Total passwords checked: %d. Total passwords passed: %d. Total passwords removed: %d."
                        % (num_lines, num_pass, num_fail)
                    )
    logger.info(
        "Password cleaning done! Total passwords checked: %d. Total passwords passed: %d. Total passwords removed: %d."
        % (num_lines, num_pass, num_fail)
    )


def do_generate(input_args):
    opts = vars(input_args)
    if input_args.is_offline:
        logger.info(
            "Now starting generation process for offline generation mode."
        )
        lpf = LavaPasswordFactory(**opts)
        lpc = LavaPasswordChecker(**opts)
        num_gen = 0
        num_pass = 0
        num_fail = 0
        with open(input_args.output_file, "w+") as f:
            for cur_pass in lpf.gen():
                num_gen += 1
                if lpc.is_valid(cur_pass):
                    num_pass += 1
                    f.write(cur_pass + "\n")
                else:
                    num_fail += 1
                if num_gen % 500000 == 0:
                    # print(cur_pass)
                    logger.info(
                        "Passwords generated: %d. Passed and written to file: %d. Failed validation checks: %d."
                        % (num_gen, num_pass, num_fail)
                    )
        logger.info(
            "File written successfully! Exiting."
        )
    else:
        logger.info(
            "Now starting generation process for online generation mode."
        )
        lpf = LavaPasswordFactory(**opts)
        results = []
        for cur_pass in lpf.gen():
            results.append(cur_pass)
        logger.info(
            "Adding top ten-thousand most common passwords to list."
        )
        results.extend(decode_top_ten_thousand())
        lpc = LavaPasswordChecker(**opts)
        clean_list = lpc.filter_list(results)
        logger.info(
            "Password generation and cleaning completed! Now writing to file %s."
            % (input_args.output_file)
        )
        with open(input_args.output_file, "w+") as f:
            f.write("\n".join(clean_list))
        logger.info(
            "File written successfully! Exiting."
        )


def decode_top_ten_thousand():
    with tempfile.TemporaryFile() as f:
        f.write(base64.b64decode(top_ten_thousand_enc))
        f.flush()
        f.seek(0)
        gzf = gzip.GzipFile(mode='rb', fileobj=f)
        contents = gzf.read()
    return contents.strip().split("\n")


def main():
    print_greeting()
    args = parse_arguments()
    args = clean_arguments(args)
    configure_logging(args.log_level)
    start_time = datetime.now()
    logger.info(
        "Script invocation starting at time %s."
        % (start_time.strftime("%m/%d/%Y %H:%M:%S"))
    )
    args.func(args)
    end_time = datetime.now()
    elapsed = end_time - start_time
    logger.info(
        "Script completed at time %s. Elapsed time was %s seconds."
        % (end_time.strftime("%m/%d/%Y %H:%M:%S"), elapsed.seconds)
    )


def parse_arguments():
    parser = argparse.ArgumentParser(
        description="LavaPasswordFactory - for all your password list creation needs."
    )
    subparsers = parser.add_subparsers(help='sub-command help')
    parser.add_argument(
        "--log-level",
        required=False,
        help="The log message level to receive when running the script. Valid "
            "values are DEBUG, INFO, WARNING, ERROR, CRITICAL.",
        action="store",
        dest="log_level",
        metavar="<DEBUG|INFO|WARNING|ERROR|CRITICAL>",
        default="INFO",
        type=str
    )
    generator_parser = subparsers.add_parser('generate', help='generate help')
    generator_parser.add_argument(
        "--special-chars",
        required=False,
        help="The characters to be considered as 'special characters' for the "
            "purpose of filtering out ineligible passwords.",
        action="store",
        dest="special_chars",
        metavar="<chars>",
        default="!@#$%^&*()-_=+{}|[]\\;:'\",<.>/?",
        type=str
    )
    generator_parser.add_argument(
        "--illegal-chars",
        required=False,
        help="Characters that are not allowed in the generated passwords.",
        action="store",
        dest="illegal_chars",
        metavar="<chars>",
        default=None,
        type=str
    )
    generator_parser.add_argument(
        "--max-special",
        required=False,
        help="The maximum number of special characters per generated password.",
        action="store",
        dest="max_special_chars",
        metavar="<num>",
        default=None,
        type=int
    )
    generator_parser.add_argument(
        "--min-special",
        required=False,
        help="The minimum number of special characters per generated password.",
        action="store",
        dest="min_special_chars",
        metavar="<num>",
        default=None,
        type=int
    )
    generator_parser.add_argument(
        "--max-caps",
        required=False,
        help="The maximum number of capital letters per generated password.",
        action="store",
        dest="max_caps",
        metavar="<num>",
        default=None,
        type=int
    )
    generator_parser.add_argument(
        "--min-caps",
        required=False,
        help="The minimum number of capital letters per generated password.",
        action="store",
        dest="min_caps",
        metavar="<num>",
        default=None,
        type=int
    )
    generator_parser.add_argument(
        "--is-offline",
        required=False,
        help="Whether or not to configure the LavaPasswordFactory to produce a password "
            "list suited for offline attacks (significantly larger than for online "
            "attacks). Flying this flag enables the offline mode.",
        action="store_true",
        default=False,
        dest="is_offline"
    )
    generator_parser.add_argument(
        "--min-length",
        required=False,
        help="The minimum length for generated passwords.",
        action="store",
        default=8,
        dest="min_length",
        metavar="<len>",
        type=int
    )
    generator_parser.add_argument(
        "--max-length",
        required=False,
        help="The maximum length for generated passwords.",
        action="store",
        default=12,
        dest="max_length",
        metavar="<len>",
        type=int
    )
    generator_parser.add_argument(
        "--words",
        required=True,
        help="The list of words used as the seeds for the password generation process, "
            "seperated by spaces. For instance, \"hello goodbye\" would result in "
            "['hello', 'goodbye'] as the input words",
        action="store",
        dest="input_list",
        metavar="<word_list>"
    )
    generator_parser.add_argument(
        "--output-file",
        required=True,
        help="Path to the file that the resulting passwords should be written to.",
        action="store",
        dest="output_file",
        metavar="<file_path>",
        type=str
    )
    generator_parser.set_defaults(func=do_generate)
    cleaner_parser = subparsers.add_parser('clean', help='clean help')
    cleaner_parser.add_argument(
        "--special-chars",
        required=False,
        help="The characters to be considered as 'special characters' for the "
            "purpose of filtering out ineligible passwords.",
        action="store",
        dest="special_chars",
        metavar="<chars>",
        default="!@#$%^&*()-_=+{}|[]\\;:'\",<.>/?",
        type=str
    )
    cleaner_parser.add_argument(
        "--illegal-chars",
        required=False,
        help="Characters that are not allowed in the generated passwords.",
        action="store",
        dest="illegal_chars",
        metavar="<chars>",
        default=None,
        type=str
    )
    cleaner_parser.add_argument(
        "--max-special",
        required=False,
        help="The maximum number of special characters per generated password.",
        action="store",
        dest="max_special_chars",
        metavar="<num>",
        default=None,
        type=int
    )
    cleaner_parser.add_argument(
        "--min-special",
        required=False,
        help="The minimum number of special characters per generated password.",
        action="store",
        dest="min_special_chars",
        metavar="<num>",
        default=None,
        type=int
    )
    cleaner_parser.add_argument(
        "--max-caps",
        required=False,
        help="The maximum number of capital letters per generated password.",
        action="store",
        dest="max_caps",
        metavar="<num>",
        default=None,
        type=int
    )
    cleaner_parser.add_argument(
        "--min-caps",
        required=False,
        help="The minimum number of capital letters per generated password.",
        action="store",
        dest="min_caps",
        metavar="<num>",
        default=None,
        type=int
    )
    cleaner_parser.add_argument(
        "--min-length",
        required=False,
        help="The minimum length for generated passwords.",
        action="store",
        default=8,
        dest="min_length",
        metavar="<len>",
        type=int
    )
    cleaner_parser.add_argument(
        "--max-length",
        required=False,
        help="The maximum length for generated passwords.",
        action="store",
        default=12,
        dest="max_length",
        metavar="<len>",
        type=int
    )
    cleaner_parser.add_argument(
        "--input-file",
        required=True,
        help="Path to the file that the existing password list to clean resides in.",
        action="store",
        dest="input_file",
        metavar="<file_path>",
        type=str
    )
    cleaner_parser.add_argument(
        "--output-file",
        required=True,
        help="Path to the file that the resulting passwords should be written to.",
        action="store",
        dest="output_file",
        metavar="<file_path>",
        type=str
    )
    cleaner_parser.set_defaults(func=do_clean)
    return parser.parse_args()


def print_greeting():
    print(LavaUIFactory.get_colorized_lavalamp_splash())
    print("                         /***************************\                             ")
    print("-= Presents the \033[31mLavaPasswordFactory\033[0m, for all your password list generation needs =-")
    print("                         \***************************/                             ")
    print("")


def validate_arguments(arguments):
    pass

logger = logging.getLogger("LavaPasswordFactory")

if __name__ == '__main__':
    main()

#TODO Create better list based off of input word, and restrict input to a single word
#TODO Do sort+uniq for the offline lists after list creation completes
#TODO Configurable interval for cleaning reporting
#TODO Configurable interval for offline list reporting
#TODO Finish filling out clean_arguments function
#TODO Fill out validate_arguments function
#TODO Write unit tests
#TODO Throw exceptions for setters for properties that shouldn't be assigned to
#TODO Do the logging.whatever thing that Moloch recommended.
#TODO Verify that the basic_permutations property will contain all permutations other than those with repeats (ie: no FoxFox)
#TODO Consider ONLY creating passwords of the specified length in the __gen function - might be too much of a headache
